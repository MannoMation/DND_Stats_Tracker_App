import sysfrom tkinter import messageboximport requestsimport subprocess# Define the repository and SSH URLREPO_OWNER = 'MannoMation'REPO_NAME = 'DND_Stats_Tracker_App'GITHUB_API_URL = f'https://api.github.com/repos/{REPO_OWNER}/{REPO_NAME}/releases'CURRENT_EXE_PATH = sys.argv[0]  # Current executable pathcurrentVersion = "v0.1.2"# Check for a newer release in the GitHub repositorydef check_for_update():    try:        response = requests.get(GITHUB_API_URL)        response.raise_for_status()        releases = response.json()        if releases:            if releases[0]["tag_name"] > currentVersion:                latest_release = releases[0]  # Get the latest release                tag_name = latest_release['tag_name']                download_url = latest_release['assets'][0]['browser_download_url']  # Assuming you want the first asset                print("New Release")                return tag_name, download_url            print("Up to Date")            return None, None        else:            print("No releases found.")            return None, None    except requests.exceptions.RequestException as e:        print(f"Error fetching release info: {e}")        return None, None# Download the release (which is the new .exe)def download_release(download_url):    try:        response = requests.get(download_url)        response.raise_for_status()        # Save the downloaded .exe to a temporary file        temp_file_name = 'new_exe_temp.exe'        with open(temp_file_name, 'wb') as file:            file.write(response.content)        print(f"Downloaded {temp_file_name}")        return temp_file_name    except requests.exceptions.RequestException as e:        print(f"Error downloading release: {e}")        return Nonedef rename_exe():    bat_content = f"""    @echo off    REM Wait for the current executable to close    timeout /t 2 /nobreak    REM Replace the old executable with the new one    move /Y "Temp_DND.exe" "DND_Stats.exe"        DEL "%~f0"    """    # Save the .bat file to a temporary location    bat_file_path = 'rename.bat'    with open(bat_file_path, 'w') as bat_file:        bat_file.write(bat_content)    # Run the batch file    subprocess.Popen(['cmd.exe', '/c', 'rename.bat', CURRENT_EXE_PATH],                     creationflags=subprocess.CREATE_NEW_CONSOLE, shell=True)def create_and_run_bat(temp_file_name):    bat_content = f"""    @echo off    REM Wait for the current executable to close    timeout /t 2 /nobreak        REM Replace the old executable with the new one    del "{CURRENT_EXE_PATH}"    timeout /t 2 /nobreak    move /Y "{temp_file_name}" "Temp_DND.exe"        REM Restart the new executable    start "" "Temp_DND.exe"        DEL "%~f0"    """    # Save the .bat file to a temporary location    bat_file_path = 'update.bat'    with open(bat_file_path, 'w') as bat_file:        bat_file.write(bat_content)    # Run the batch file    subprocess.Popen(['cmd.exe', '/c', 'update.bat', CURRENT_EXE_PATH],                     creationflags=subprocess.CREATE_NEW_CONSOLE, shell=True)    #subprocess.Popen(bat_file_path)    print(f"Running {bat_file_path} to update the executable.")# Main function to check for updates and update the .exedef main():    tag_name, download_url = check_for_update()    if tag_name:        response = messagebox.askyesno("Update", "There is a new update for this app. Do you want to download?")        if response:            file_name = download_release(download_url)            if file_name:                create_and_run_bat(file_name)                sys.exit()